"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const OpenAPI_1 = require("./core/OpenAPI");
const JobsService_1 = require("./services/JobsService");
const CoverageService_1 = require("./services/CoverageService");
const ValidationSchemas_1 = require("./validation/ValidationSchemas");
const zod_1 = require("zod");
// Main class for interacting with Civitai services
class Civitai {
    constructor(config) {
        const baseURL = config.env === "dev"
            ? "https://orchestration-dev.civitai.com"
            : "https://orchestration.civitai.com";
        OpenAPI_1.OpenAPI.BASE = baseURL;
        OpenAPI_1.OpenAPI.HEADERS = {
            Authorization: `Bearer ${config.auth}`,
        };
        // Image-related operations
        this.image = {
            // Convert text to image, optionally not waiting for job completion
            fromText: (input, wait = false) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                // Runtime validation
                try {
                    ValidationSchemas_1.fromTextSchema.parse(input);
                }
                catch (error) {
                    if (error instanceof zod_1.ZodError) {
                        throw new Error(`Validation error: ${error.message}`);
                    }
                }
                // Infer the baseModel from the model value
                const baseModel = input.model.includes("sdxl") ? "SDXL" : "SD_1_5";
                // Prepare job input with default values
                const jobInput = Object.assign({ $type: "textToImage", baseModel }, input);
                console.log(`Creating TextToImage job with input=`, jobInput);
                // Submit job and process response
                const response = yield JobsService_1.JobsService.postV1ConsumerJobs(wait, false, // detailed = false
                // @ts-ignore
                jobInput);
                const modifiedResponse = {
                    token: response.token,
                    jobs: response.jobs.map((job) => ({
                        jobId: job.jobId,
                        cost: job.cost,
                        result: job.result,
                        scheduled: job.scheduled,
                    })),
                };
                // If waiting for job completion, poll until job is done
                if (wait) {
                    try {
                        const jobResult = yield this.pollForJobCompletion(response.token);
                        if (jobResult && modifiedResponse.jobs.length > 0) {
                            modifiedResponse.jobs[0].result = jobResult;
                        }
                    }
                    catch (error) {
                        console.error(`${error}`);
                    }
                }
                return modifiedResponse;
            }),
            // Convert comfy input to output, optionally not waiting for job completion
            fromComfy: (input, wait = false) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const jobInput = Object.assign({ $type: "comfy" }, input);
                console.log(`Creating ComfyUI job with input=`, JSON.stringify(jobInput, null, 2));
                // Submit job and process response
                const response = yield JobsService_1.JobsService.postV1ConsumerJobs(wait, false, 
                // @ts-ignore
                jobInput);
                const modifiedResponse = {
                    token: response.token,
                    jobs: response.jobs.map((job) => ({
                        jobId: job.jobId,
                        cost: job.cost,
                        result: job.result,
                        scheduled: job.scheduled,
                    })),
                };
                // If waiting for job completion, poll until job is done
                if (wait) {
                    try {
                        const jobResult = yield this.pollForJobCompletion(response.token);
                        if (jobResult && modifiedResponse.jobs.length > 0) {
                            modifiedResponse.jobs[0].result = jobResult;
                        }
                    }
                    catch (error) {
                        console.error(`${error}`);
                    }
                }
                return modifiedResponse;
            }),
        };
        this.models = {
            // Get coverage of particular models
            get: (model) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                console.log(`Fetching coverage for models:`, model);
                try {
                    const coverage = yield CoverageService_1.CoverageService.getV1ConsumerCoverage(model);
                    return coverage;
                }
                catch (error) {
                    console.error(`Error fetching model coverage: ${error}`);
                    throw error;
                }
            }),
        };
        // Job-related operations
        this.jobs = {
            // Fetch job status by jobId
            getById: (jobId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const response = yield JobsService_1.JobsService.getV1ConsumerJobs1(jobId);
                const modifiedResponse = {
                    jobId: response.jobId,
                    cost: response.cost,
                    result: response.result,
                    scheduled: response.scheduled,
                };
                return modifiedResponse;
            }),
            // Fetch jobs by token
            getByToken: (token) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var _a;
                const response = yield JobsService_1.JobsService.getV1ConsumerJobs(token);
                const modifiedResponse = (_a = response.jobs) === null || _a === void 0 ? void 0 : _a.map((job) => ({
                    jobId: job.jobId,
                    cost: job.cost,
                    result: job.result,
                    scheduled: job.scheduled,
                }));
                return { token, jobs: modifiedResponse };
            }),
            // Fetch jobs by query
            getByQuery: (query, detailed = false) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    const response = yield JobsService_1.JobsService.postV1ConsumerJobsQuery(detailed, query);
                    return response;
                }
                catch (error) {
                    console.error(`Error fetching jobs by query: ${error}`);
                    throw error;
                }
            }),
            // Cancel a job by jobId
            cancel: (jobId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                console.log(`Cancelling job with jobId ${jobId}`);
                try {
                    yield JobsService_1.JobsService.deleteV1ConsumerJobs1(jobId, true); // force=true by default
                    return {
                        status: 200,
                        message: `Job ${jobId} cancelled successfully.`,
                    };
                }
                catch (error) {
                    console.error(`Error cancelling job ${jobId}: ${error}`);
                    throw error;
                }
            }),
        };
    }
    // Poll for job completion with a timeout
    pollForJobCompletion(token, interval = 30000, // Poll every 30 seconds
    timeout = 600000 // Timeout after 10 minutes
    ) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const startTime = Date.now();
            const checkJobStatus = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                // Check for timeout
                if (Date.now() - startTime > timeout) {
                    throw new Error(`Polling timeout exceeded for token ${token}`);
                }
                // Check job status
                const response = yield this.jobs.getByToken(token);
                const job = response.jobs && response.jobs[0];
                if (job && job.result && job.result.blobUrl) {
                    return response;
                }
                else if (job && !job.scheduled) {
                    // If the job is not scheduled and there's no blobUrl, throw an error
                    throw new Error(`Job ${job.jobId} is not scheduled and has no result. Stopping polling.`);
                }
                else {
                    console.log(`Job:`, JSON.stringify(response, null, 2));
                    yield new Promise((resolve) => setTimeout(resolve, interval));
                    return checkJobStatus();
                }
            });
            return checkJobStatus();
        });
    }
}
exports.default = Civitai;
